theme(plot.title = element_text(face = "bold", size = 16))
legend_data <- expand.grid(x = 1:3, y = 1:3) %>%
mutate(bi_class = paste0(x, "-", y))
legend2 <- ggplot(legend_data, aes(x = x, y = y, fill = bi_class)) +
geom_tile() +
scale_fill_manual(values = bivariate_colors2, guide = "none") +
labs(x = "Rent →", y = "Evict. →") +
theme_void() +
theme(
axis.title.x = element_text(size = 9, margin = margin(t = 5)),
axis.title.y = element_text(size = 9, angle = 90, margin = margin(r = 5))
) +
coord_fixed()
final_plot2 <- ggdraw() +
draw_plot(map2, 0, 0, 1, 1) +
draw_plot(legend2, 0.7, 0.05, 0.22, 0.22)
library(ggplot2)
# prepare data
map_data <- df_final %>%
group_by(GEOID) %>%
summarise(
total_filings = sum(filings_2020, na.rm = TRUE),
median_income = first(median_hh_income),
.groups = "drop"
)
map_sf <- philly_tract_sf %>%
left_join(map_data, by = "GEOID") %>%
filter(!is.na(total_filings) & !is.na(median_income))
# create tertiles for each variable
map_sf <- map_sf %>%
mutate(
filings_class = ntile(total_filings, 3),
income_class = ntile(median_income, 3),
bi_class = paste0(income_class, "-", filings_class)
)
# define bivariate color palette (blue-red for income-eviction)
bivariate_colors3 <- c(
"1-1" = "#e8e8e8",  # Low income, Low evictions
"2-1" = "#b5c0da",  # Med income, Low evictions
"3-1" = "#6c83b5",  # High income, Low evictions
"1-2" = "#f0b8b8",  # Low income, Med evictions
"2-2" = "#ad9ea5",  # Med income, Med evictions
"3-2" = "#567994",  # High income, Med evictions
"1-3" = "#e64b35",  # Low income, High evictions
"2-3" = "#985356",  # Med income, High evictions
"3-3" = "#3b4994"   # High income, High evictions
)
# map
map3 <- ggplot(map_sf) +
geom_sf(aes(fill = bi_class), color = NA) +
scale_fill_manual(values = bivariate_colors3, na.value = "grey90", guide = "none") +
labs(
title = "Eviction Filings vs Median Household Income",
subtitle = "Orange = High evictions AND low income"
) +
theme_void() +
theme(plot.title = element_text(face = "bold", size = 16))
legend_data <- expand.grid(x = 1:3, y = 1:3) %>%
mutate(bi_class = paste0(x, "-", y))
legend3 <- ggplot(legend_data, aes(x = x, y = y, fill = bi_class)) +
geom_tile() +
scale_fill_manual(values = bivariate_colors3, guide = "none") +
labs(x = "Income →", y = "Evict. →") +
theme_void() +
theme(
axis.title.x = element_text(size = 9, margin = margin(t = 5)),
axis.title.y = element_text(size = 9, angle = 90, margin = margin(r = 5))
) +
coord_fixed()
final_plot3 <- ggdraw() +
draw_plot(map3, 0, 0, 1, 1) +
draw_plot(legend3, 0.7, 0.05, 0.22, 0.22)
install.packages("cowplot")
install.packages("cowplot")
library(cowplot)
View(df_census_sf)
df_census_sf=philly_tract_sf%>%
left_join(df_census,by="GEOID")
crs(df_census_sf)
census_points=st_centroid(df_census_sf)
points_joined <- st_join(census_points, philly_neighborhoods)
colnames(points_joined)
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
# Join the result back to the polygon layer
df_census_sf_final <- df_census_sf %>%
left_join(mean_mhi_by_poly, by = "MAPNAME")%>%
st_as_sf()
df_census_sf=st_join(sf_census_sf,philly_neighborhoods)
df_census_sf=st_join(df_census_sf,philly_neighborhoods)
# Join the result back to the polygon layer
df_census_sf_final <- df_census_sf %>%
left_join(mean_mhi_by_poly, by = "MAPNAME")%>%
st_as_sf()
# reclassify the neighborhood data based on quantile (25%)
df_census_sf_final$MHI_quantile <- cut(
df_census_sf_final$meanMHI,
breaks = quantile(
df_census_sf_final$meanMHI,
probs = seq(0, 1, 0.25),
na.rm = TRUE
),
include.lowest = TRUE,
labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)
View(df_census_sf_final)
#merge with eviction data
df_final=df_census_sf_final%>%
mutate(date=format(week_date,"%Y-%m"))%>%
filter(year(week_date) %in% c(2020:2023))%>%
left_join(rent_by_month_tract,by=c("date","GEOID"))%>%
select(GEOID,unemployment_rate,foodcpi,electricitycpi,avg_wkly_wage,
filings_2020,comcpi,total_pop,pct_white,pct_black,pct_asian,
median_hh_income,pct_renter,median_year_built_renter,aggregate_rooms,
median_rooms,total_hh,pct_family,median_rent.y,MHI_quantile,week_date)
colnames(df_final)
#filter 2020 April, may and June and
df_filtered = df %>%
filter(week_date != ymd("2020-04-01"|"2020-05-01"|"2020-06-01"))
#filter 2020 April, may and June and
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))
df_filtered$evibypop=df_filtered$filings_avg/df_filtered$total_pop
model1=lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data=df_filtered)
colnames(df$filtered)
colnames(df_filtered)
#calculate eviction by population
df_final$evibypop=df_final$filings_avg/df_final$total_pop
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_final[train_indices, ]
test_data <- df_final[-train_indices, ]
set.seed(123)
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
#run regression based on census characteristic
options(scipen = 999)
model1=lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data=df_filtered)
summary(model1)
vif(model1)
bptest(model1)
#calculate the RMSE
model_train_1 <- lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$log_price - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
plot(model1)
model2=lm(evibypop~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data=df_final)
summary(model2)
vif(model2)
bptest(model2)
rmse_test_1 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
plot(model1)
#calculate the RMSE
model_train_2 <- lm(evibypop~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
summary(df_filtered)
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))
model1=lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data=df_filtered)
#calculate the RMSE
model_train_1 <- lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
summary(df_filtered)
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
#calculate the RMSE
model_train_1 <- lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
rmse_test_1 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
rmse_test_1 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))%>%
filter(!total_pop==0)
summary(df_filtered)
summary(df_census_sf_final)
summary(rent_by_month_tract)
summary(df_final)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))%>%
filter(!total_pop==0)%>%
filter(median_rent==NA)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))%>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
#calculate the RMSE
model_train_1 <- lm(evibypop~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
rmse_train_1 <- summary(model_train_1)$sigma
summary(df_filtered)
#calculate the RMSE
model_train_1 <- lm(filings_2020~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
hist(df_filtered$filings_2020)
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
pull(filings_2020) %>%
quantile(probs = 0.99, na.rm = TRUE)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!week_date %in% c(ymd("2020-04-01"), ymd("2020-05-01"), ymd("2020-06-01")))%>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
summary(df_filtered)
set.seed(123)
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
#calculate the RMSE
model_train_1 <- lm(filings_2020~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
#calculate the RMSE
model_train_2 <- lm(evibypop~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$evibypop - test_predictions_1)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
summary(df_filtered)
#calculate the RMSE
model_train_1 <- lm(filings_2020~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian+total_pop,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
model3=lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop+MHI_quantile,data=df_final)
summary(model3)
vif(model3)
bptest(model3)
model3=lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data=df_final)
vif(model3)
model_train_3 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#merge with eviction data
df_final=df_census_sf_final%>%
mutate(date=format(week_date,"%Y-%m"))%>%
filter(year(week_date) %in% c(2020:2023))%>%
left_join(rent_by_month_tract,by=c("date","GEOID"))%>%
select(GEOID,unemployment_rate,foodcpi,electricitycpi,avg_wkly_wage,
filings_2020,comcpi,total_pop,pct_white,pct_black,pct_asian,
median_hh_income,pct_renter,median_year_built_renter,aggregate_rooms,
median_rooms,total_hh,pct_family,median_rent.y,MHI_quantile,week_date,year)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!year==2020)%>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
set.seed(123)
n <- nrow(df_filtered)
train_data <- df_filtered[train_indices, ]
#calculate the RMSE
model_train_1 <- lm(filings_2020~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian+total_pop,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
model_train_3 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
summary(df_filtered)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+MHI_quantile,data = train_data)
library(MASS)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+factor(year)+MHI_quantile,data = train_data)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+factor(year)+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
# 1. Fit the model (I added offset(log(total_pop)) which is best practice for rates)
model_train_3 <- glm.nb(
filings_2020 ~ median_rent.y + avg_wkly_wage + median_hh_income +
pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + electricitycpi + factor(year) +
MHI_quantile + offset(log(total_pop)),
data = train_data
)
# 2. Predict on TEST data
# NOTE: type = "response" is crucial to get 'counts' instead of 'log-odds'
test_predictions_3 <- predict(model_train_3, newdata = test_data, type = "response")
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
n <- nrow(df_filtered)
# 2. Predict on TEST data
# NOTE: type = "response" is crucial to get 'counts' instead of 'log-odds'
test_predictions_3 <- predict(model_train_3, newdata = test_data, type = "response")
# 3. Calculate TEST RMSE
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2, na.rm = TRUE))
# 4. Calculate TRAIN RMSE (Replacement for 'sigma')
# We must predict on the training data manually to get an equivalent metric
train_predictions_3 <- predict(model_train_3, newdata = train_data, type = "response")
rmse_train_3 <- sqrt(mean((train_data$filings_2020 - train_predictions_3)^2, na.rm = TRUE))
# Print results
print(paste("Train RMSE:", round(rmse_train_3, 2)))
print(paste("Test RMSE:", round(rmse_test_3, 2)))
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data_clean
)
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data_clean, type = "response")
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data, type = "response")
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_2 <- predict(model_train_2, newdata = train_data, type = "response")
rmse_train_2 <- sqrt(mean((train_data$filings_2020 - train_predictions_2)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_2, 2)))
print(paste("Test RMSE:", round(rmse_test_2, 2)))
plot(model2)
summary(df_final)
summary(df_census_sf_final)
#p-value is way too small, implying more variables may be needed (make sense)
#calculate the RMSE
model_train_1 <- glm.nb(
filings_2020 ~ pct_white + median_hh_income + pct_renter + unemployment_rate +
median_year_built_renter + aggregate_rooms + pct_family + total_hh +
pct_black + pct_asian + offset(log(total_pop)),
data = train_data
)
# 3. PREDICT & EVALUATE
# Use type = "response" to get actual eviction counts
# Test RMSE
test_predictions_1 <- predict(model_train_1, newdata = test_data, type = "response")
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_1 <- predict(model_train_1, newdata = train_data, type = "response")
rmse_train_1 <- sqrt(mean((train_data$filings_2020 - train_predictions_1)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_1, 2)))
print(paste("Test RMSE:", round(rmse_test_1, 2)))
plot(model1)
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data, type = "response")
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_2 <- predict(model_train_2, newdata = train_data, type = "response")
rmse_train_2 <- sqrt(mean((train_data$filings_2020 - train_predictions_2)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_2, 2)))
print(paste("Test RMSE:", round(rmse_test_2, 2)))
plot(model2)
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
outlier_threshold <- df_final %>%
filter(!is.na(filings_2020)) %>%
pull(filings_2020) %>%
quantile(probs = 0.99)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
colnames(df_filtered)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)%in%(ymd("2020-03-01"):ymd("2021-08-01")),1,0))
View(df_filtered)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)>(ymd("2020-02-01")|ymd(week_date)<ymd("2021-09-01")),1,0))
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)>(ymd("2020-02-01")&ymd(week_date)<ymd("2021-09-01")),1,0))
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora = ifelse(ymd(week_date) > ymd("2020-02-01") & ymd(week_date) < ymd("2021-09-01"), 1, 0))
View(df_filtered)
set.seed(123)
n <- nrow(df_filtered)
train_data <- df_filtered[train_indices, ]
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
