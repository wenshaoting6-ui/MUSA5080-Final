test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
model3=lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop+MHI_quantile,data=df_final)
summary(model3)
vif(model3)
bptest(model3)
model3=lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data=df_final)
vif(model3)
model_train_3 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
#merge with eviction data
df_final=df_census_sf_final%>%
mutate(date=format(week_date,"%Y-%m"))%>%
filter(year(week_date) %in% c(2020:2023))%>%
left_join(rent_by_month_tract,by=c("date","GEOID"))%>%
select(GEOID,unemployment_rate,foodcpi,electricitycpi,avg_wkly_wage,
filings_2020,comcpi,total_pop,pct_white,pct_black,pct_asian,
median_hh_income,pct_renter,median_year_built_renter,aggregate_rooms,
median_rooms,total_hh,pct_family,median_rent.y,MHI_quantile,week_date,year)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!year==2020)%>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
set.seed(123)
n <- nrow(df_filtered)
train_data <- df_filtered[train_indices, ]
#calculate the RMSE
model_train_1 <- lm(filings_2020~pct_white+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+aggregate_rooms+pct_family+total_hh+pct_black+pct_asian+total_pop,data = train_data)
test_predictions_1 <- predict(model_train_1, newdata = test_data)
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2,na.rm = TRUE))
rmse_train_1 <- summary(model_train_1)$sigma
#calculate the RMSE
model_train_2 <- lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+comcpi+total_pop,data = train_data)
test_predictions_2 <- predict(model_train_2, newdata = test_data)
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2,na.rm = TRUE))
rmse_train_2 <- summary(model_train_2)$sigma
model_train_3 <- lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
summary(df_filtered)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+MHI_quantile,data = train_data)
library(MASS)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
rmse_train_3 <- summary(model_train_3)$sigma
test_predictions_3 <- predict(model_train_3, newdata = test_data)
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2,na.rm = TRUE))
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+factor(year)+MHI_quantile,data = train_data)
model_train_3 <- glm.nb(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+I(total_pop)+factor(year)+MHI_quantile,data = train_data)
test_predictions_3 <- predict(model_train_3, newdata = test_data)
# 1. Fit the model (I added offset(log(total_pop)) which is best practice for rates)
model_train_3 <- glm.nb(
filings_2020 ~ median_rent.y + avg_wkly_wage + median_hh_income +
pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + electricitycpi + factor(year) +
MHI_quantile + offset(log(total_pop)),
data = train_data
)
# 2. Predict on TEST data
# NOTE: type = "response" is crucial to get 'counts' instead of 'log-odds'
test_predictions_3 <- predict(model_train_3, newdata = test_data, type = "response")
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
n <- nrow(df_filtered)
# 2. Predict on TEST data
# NOTE: type = "response" is crucial to get 'counts' instead of 'log-odds'
test_predictions_3 <- predict(model_train_3, newdata = test_data, type = "response")
# 3. Calculate TEST RMSE
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2, na.rm = TRUE))
# 4. Calculate TRAIN RMSE (Replacement for 'sigma')
# We must predict on the training data manually to get an equivalent metric
train_predictions_3 <- predict(model_train_3, newdata = train_data, type = "response")
rmse_train_3 <- sqrt(mean((train_data$filings_2020 - train_predictions_3)^2, na.rm = TRUE))
# Print results
print(paste("Train RMSE:", round(rmse_train_3, 2)))
print(paste("Test RMSE:", round(rmse_test_3, 2)))
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data_clean
)
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data_clean, type = "response")
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data, type = "response")
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_2 <- predict(model_train_2, newdata = train_data, type = "response")
rmse_train_2 <- sqrt(mean((train_data$filings_2020 - train_predictions_2)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_2, 2)))
print(paste("Test RMSE:", round(rmse_test_2, 2)))
plot(model2)
summary(df_final)
summary(df_census_sf_final)
#p-value is way too small, implying more variables may be needed (make sense)
#calculate the RMSE
model_train_1 <- glm.nb(
filings_2020 ~ pct_white + median_hh_income + pct_renter + unemployment_rate +
median_year_built_renter + aggregate_rooms + pct_family + total_hh +
pct_black + pct_asian + offset(log(total_pop)),
data = train_data
)
# 3. PREDICT & EVALUATE
# Use type = "response" to get actual eviction counts
# Test RMSE
test_predictions_1 <- predict(model_train_1, newdata = test_data, type = "response")
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_1 <- predict(model_train_1, newdata = train_data, type = "response")
rmse_train_1 <- sqrt(mean((train_data$filings_2020 - train_predictions_1)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_1, 2)))
print(paste("Test RMSE:", round(rmse_test_1, 2)))
plot(model1)
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data, type = "response")
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_2 <- predict(model_train_2, newdata = train_data, type = "response")
rmse_train_2 <- sqrt(mean((train_data$filings_2020 - train_predictions_2)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_2, 2)))
print(paste("Test RMSE:", round(rmse_test_2, 2)))
plot(model2)
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
outlier_threshold = df_final %>%
filter(!is.na(filings_2020)) %>%
quantile(probs = 0.99, na.rm = TRUE)
outlier_threshold <- df_final %>%
filter(!is.na(filings_2020)) %>%
pull(filings_2020) %>%
quantile(probs = 0.99)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)
colnames(df_filtered)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)%in%(ymd("2020-03-01"):ymd("2021-08-01")),1,0))
View(df_filtered)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)>(ymd("2020-02-01")|ymd(week_date)<ymd("2021-09-01")),1,0))
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora=ifelse(ymd(week_date)>(ymd("2020-02-01")&ymd(week_date)<ymd("2021-09-01")),1,0))
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora = ifelse(ymd(week_date) > ymd("2020-02-01") & ymd(week_date) < ymd("2021-09-01"), 1, 0))
View(df_filtered)
set.seed(123)
n <- nrow(df_filtered)
train_data <- df_filtered[train_indices, ]
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
colnames(df_final)
df_census_sf
colnames(df_census_sf)
df_census=df%>%
left_join(philly_tract_data,by="GEOID")
library(tidycensus)
library(tidyverse)
library(here)
library(lubridate)
library(dplyr)
library(sf)
library(tigris)
library(spatstat)
library(terra)
library(ggplot2)
library(arrow)
library(tigris)
library(car)
library(lmtest)
library(spdep)
library(ggpubr)
library(ggplot2)
library(cowplot)
library(MASS)
df_census=df%>%
left_join(philly_tract_data,by="GEOID")
df_census_sf=philly_tract_sf%>%
left_join(df_census,by="GEOID")
neighborhood_folder <- here("data", "philadelphia-neighborhoods")
neighborhood_path   <- file.path(neighborhood_folder, "philadelphia-neighborhoods.shp")
# Read the shapefile
philly_neighborhoods <- st_read(neighborhood_path, quiet = TRUE)
philly_neighborhoods=st_transform(philly_neighborhoods, crs=32618)
df_census_sf=st_join(df_census_sf,philly_neighborhoods)
census_points=st_centroid(df_census_sf)
points_joined <- st_join(census_points, philly_neighborhoods)
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
points_joined <- st_join(census_points, philly_neighborhoods)
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
View(points_joined)
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME.y) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
# Join the result back to the polygon layer
df_census_sf_final <- df_census_sf %>%
left_join(mean_mhi_by_poly, by = "MAPNAME")%>%
st_as_sf()
# Join the result back to the polygon layer
df_census_sf_final <- df_census_sf %>%
left_join(mean_mhi_by_poly, by = "MAPNAME.y")%>%
st_as_sf()
View(mean_mhi_by_poly)
df_census=df%>%
left_join(philly_tract_data,by="GEOID")
df_census_sf=philly_tract_sf%>%
left_join(df_census,by="GEOID")
View(df_census_sf)
neighborhood_folder <- here("data", "philadelphia-neighborhoods")
neighborhood_path   <- file.path(neighborhood_folder, "philadelphia-neighborhoods.shp")
# Read the shapefile
philly_neighborhoods <- st_read(neighborhood_path, quiet = TRUE)
philly_neighborhoods=st_transform(philly_neighborhoods, crs=32618)
census_points=st_centroid(df_census_sf)
points_joined <- st_join(census_points, philly_neighborhoods)
df_census_sf=st_join(df_census_sf,philly_neighborhoods)
# Calculate mean MHI for each polygon
mean_mhi_by_poly <- points_joined %>%
st_drop_geometry() %>%
group_by(MAPNAME) %>%
summarise(meanMHI = mean(median_hh_income, na.rm = TRUE))
# Join the result back to the polygon layer
df_census_sf_final <- df_census_sf %>%
left_join(mean_mhi_by_poly, by = "MAPNAME")%>%
st_as_sf()
# reclassify the neighborhood data based on quantile (25%)
df_census_sf_final$MHI_quantile <- cut(
df_census_sf_final$meanMHI,
breaks = quantile(
df_census_sf_final$meanMHI,
probs = seq(0, 1, 0.25),
na.rm = TRUE
),
include.lowest = TRUE,
labels = c("Q1 (lowest)", "Q2", "Q3", "Q4 (highest)")
)
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date,NEIGHBORHOOD)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE))
View(rent_by_month_tract)
View(phillyrental_proj_1923)
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date,NEIGHBORHOOD)%>%
group_by(GEOID,date)
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE))
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date)
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE))
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))%>%
select(GEOID,RENT_PRICE,date)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE,na.rm = TRUE))
#calculate rent by month and tract
rent_by_month_tract <- phillyrental_proj_1923 %>%
st_drop_geometry() %>%
mutate(date = format(DATE_POSTED, "%Y-%m")) %>%
select(GEOID, RENT_PRICE, date) %>%
group_by(GEOID, date) %>%
summarise(median_rent = median(RENT_PRICE, na.rm = TRUE)) # Added na.rm=TRUE for robustness
#calculate rent by month and tract
rent_by_month_tract <- phillyrental_proj_1923 %>% st_drop_geometry() %>% mutate(date = format(DATE_POSTED, "%Y-%m")) %>% select(GEOID, RENT_PRICE, date) %>% group_by(GEOID, date) %>% summarise(median_rent = median(RENT_PRICE, na.rm = TRUE))
#calculate rent by month and tract
rent_by_month_tract=phillyrental_proj_1923%>%
st_drop_geometry()%>%
mutate(date=format(DATE_POSTED,"%Y-%m"))
View(rent_by_month_tract)
rent_by_month_tract=rent_by_month_tract%>%
select(GEOID,RENT_PRICE,date)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE))
rent_by_month_tract=rent_by_month_tract%>%
dplyr::select(GEOID,RENT_PRICE,date)%>%
group_by(GEOID,date)%>%
summarise(median_rent=median(RENT_PRICE))
#merge with eviction data
df_final=df_census_sf_final%>%
mutate(date=format(week_date,"%Y-%m"))%>%
filter(year(week_date) %in% c(2020:2023))%>%
left_join(rent_by_month_tract,by=c("date","GEOID"))%>%
dplyr::select(GEOID,unemployment_rate,foodcpi,electricitycpi,avg_wkly_wage,
filings_2020,comcpi,total_pop,pct_white,pct_black,pct_asian,
median_hh_income,pct_renter,median_year_built_renter,aggregate_rooms,
median_rooms,total_hh,pct_family,median_rent.y,MHI_quantile,week_date,year)
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
outlier_threshold <- df_final %>%
filter(!is.na(filings_2020)) %>%
pull(filings_2020) %>%
quantile(probs = 0.99)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora = ifelse(ymd(week_date) > ymd("2020-02-01") & ymd(week_date) < ymd("2021-09-01"), 1, 0))
set.seed(123)
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
# 1. Fit the model
model_train_3 <- glm.nb(
filings_2020 ~ median_rent.y + avg_wkly_wage + median_hh_income +
pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + electricitycpi + factor(year) +
MHI_quantile + offset(log(total_pop))+mora,
data = train_data
)
# 2. Predict on TEST data
# NOTE: type = "response" is crucial to get 'counts' instead of 'log-odds'
test_predictions_3 <- predict(model_train_3, newdata = test_data, type = "response")
# 3. Calculate TEST RMSE
rmse_test_3 <- sqrt(mean((test_data$filings_2020 - test_predictions_3)^2, na.rm = TRUE))
# 4. Calculate TRAIN RMSE (Replacement for 'sigma')
# We must predict on the training data manually to get an equivalent metric
train_predictions_3 <- predict(model_train_3, newdata = train_data, type = "response")
rmse_train_3 <- sqrt(mean((train_data$filings_2020 - train_predictions_3)^2, na.rm = TRUE))
# Print results
print(paste("Train RMSE:", round(rmse_train_3, 2)))
print(paste("Test RMSE:", round(rmse_test_3, 2)))
plot(model3)
#p-value is way too small, implying more variables may be needed (make sense)
#calculate the RMSE
model_train_1 <- glm.nb(
filings_2020 ~ pct_white + median_hh_income + pct_renter + unemployment_rate +
median_year_built_renter + aggregate_rooms + pct_family + total_hh +
pct_black + pct_asian + offset(log(total_pop)),
data = train_data
)
# 3. PREDICT & EVALUATE
# Use type = "response" to get actual eviction counts
# Test RMSE
test_predictions_1 <- predict(model_train_1, newdata = test_data, type = "response")
rmse_test_1 <- sqrt(mean((test_data$filings_2020 - test_predictions_1)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_1 <- predict(model_train_1, newdata = train_data, type = "response")
rmse_train_1 <- sqrt(mean((train_data$filings_2020 - train_predictions_1)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_1, 2)))
print(paste("Test RMSE:", round(rmse_test_1, 2)))
plot(model1)
model2=lm(filings_2020~median_rent.y+foodcpi+electricitycpi+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+pct_asian+comcpi+total_pop,data=df_filtered)
summary(model2)
#calculate the RMSE
model_train_2 <- glm.nb(
filings_2020 ~ median_rent.y + foodcpi + electricitycpi + avg_wkly_wage +
median_hh_income + pct_renter + unemployment_rate + median_year_built_renter +
pct_family + pct_black + comcpi +
offset(log(total_pop)),
data = train_data
)
# Test RMSE
test_predictions_2 <- predict(model_train_2, newdata = test_data, type = "response")
rmse_test_2 <- sqrt(mean((test_data$filings_2020 - test_predictions_2)^2, na.rm = TRUE))
# Train RMSE (replacing summary$sigma)
train_predictions_2 <- predict(model_train_2, newdata = train_data, type = "response")
rmse_train_2 <- sqrt(mean((train_data$filings_2020 - train_predictions_2)^2, na.rm = TRUE))
# 4. OUTPUT
print(paste("Train RMSE:", round(rmse_train_2, 2)))
print(paste("Test RMSE:", round(rmse_test_2, 2)))
plot(model2)
model3=lm(filings_2020~median_rent.y+avg_wkly_wage+median_rent.y+median_hh_income+pct_renter+unemployment_rate+median_year_built_renter+pct_family+pct_black+electricitycpi+total_pop+MHI_quantile,data=df_filtered)
summary(model3)
df_filtered <- df_filtered %>%
arrange(GEOID, week_date) %>%
group_by(GEOID) %>%
mutate(
evictions_lag1 = lag(filings_2020, 1),
evictions_lag3 = lag(filings_2020, 3),
unemployment_lag1 = lag(unemployment_rate, 1),
rent_change = median_rent.y - lag(median_rent.y, 1)
) %>%
ungroup()
train_control <- trainControl(
method = "cv",
number = 10,
savePredictions = TRUE
)
library(caret)
train_control <- trainControl(
method = "cv",
number = 10,
savePredictions = TRUE
)
