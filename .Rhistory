summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+I(EconKDE^2),
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
colnames(df_census_sf_final)
df_final=df_census_sf_final%>%
mutate(date=format(week_date,"%Y-%m"))%>%
filter(year(week_date) %in% c(2020:2023))%>%
left_join(rent_by_month_tract,by=c("date","GEOID"))%>%
mutate(EconKDE = KDE$lyr.1)%>%
dplyr::select(GEOID,unemployment_rate,foodcpi,electricitycpi,avg_wkly_wage,
filings_2020,comcpi,total_pop,pct_white,pct_black,pct_asian,
median_hh_income,pct_renter,median_year_built_renter,aggregate_rooms,
median_rooms,total_hh,pct_family,median_rent.y,MHI_quantile,week_date,year,EconKDE,pct_rent_burdened)
#calculate eviction by population
df_final$evibypop=df_final$filings_2020/df_final$total_pop*100
outlier_threshold <- df_final %>%
filter(!is.na(filings_2020)) %>%
pull(filings_2020) %>%
quantile(probs = 0.99)
#filter 2020 April, may and June
df_filtered = df_final %>%
filter(!total_pop==0)%>%
filter(!is.na(median_rent.y))%>%
filter(filings_2020 <= outlier_threshold)%>%
mutate(mora = ifelse(ymd(week_date) > ymd("2020-02-01") & ymd(week_date) < ymd("2021-09-01"), 1, 0))
df_filtered <- df_filtered %>%
arrange(GEOID, week_date) %>%
group_by(GEOID) %>%
mutate(
evictions_lag1 = lag(filings_2020, 1),
evictions_lag3 = lag(filings_2020, 3),
unemployment_lag1 = lag(unemployment_rate, 1),
rent_change = median_rent.y - lag(median_rent.y, 1)
) %>%
ungroup()
set.seed(123)
n <- nrow(df_filtered)
# 70% training, 30% testing
train_indices <- sample(1:n, size = 0.7 * n)
train_data <- df_filtered[train_indices, ]
test_data <- df_filtered[-train_indices, ]
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
colname(train_data4)
colnames(train_data4)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+pct_rent_burdened
,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+pct_rent_burdened+
EconKDE*log_rent
,
data = train_data4
)
summary(model_train_4)
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile +
mora:pct_renter +
offset(log_pop)+EconKDE,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile  +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile  +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
# Step 1: Feature Engineering
df_model4 <- df_filtered %>%
mutate(
# Rent-to-income ratio (replaces having both separately)
rent_to_income = median_rent.y / (median_hh_income / 12),
rent_to_income = ifelse(is.infinite(rent_to_income) | rent_to_income > 2, NA, rent_to_income),
# Log transforms
log_pop = log(total_pop + 1),
log_rent = log(median_rent.y + 1),
# Temporal features
mora = ifelse(week_date >= as.Date("2020-03-01") & week_date <= as.Date("2021-08-31"), 1, 0),
post_mora = ifelse(week_date >= as.Date("2021-09-01") & week_date <= as.Date("2022-03-31"), 1, 0),
winter = ifelse(month(week_date) %in% c(11,12, 1), 1, 0)
) %>%
# Lagged unemployment
group_by(GEOID) %>%
arrange(GEOID, week_date) %>%
mutate(unemployment_lag1 = lag(unemployment_rate, 1)) %>%
mutate(unemployment_lag3 = lag(unemployment_rate, 3))%>%
ungroup() %>%
filter(!is.na(unemployment_lag1))
# Step 2: Spatial train/test split (by tract)
set.seed(123)
unique_tracts <- unique(df_model4$GEOID)
train_tracts <- sample(unique_tracts, size = 0.7 * length(unique_tracts))
train_data4 <- df_model4 %>% filter(GEOID %in% train_tracts)
test_data4 <- df_model4 %>% filter(!GEOID %in% train_tracts)
# Step 3: Fit Model 4
model_train_4 <- glm.nb(
filings_2020 ~
unemployment_rate  +unemployment_lag3+ avg_wkly_wage + electricitycpi +
log_rent + pct_renter + rent_to_income +
pct_black + pct_family +
mora + post_mora + winter + factor(year) +
MHI_quantile  +
offset(log_pop)+EconKDE+pct_rent_burdened,
data = train_data4
)
summary(model_train_4)
# Step 4: Evaluate
test_predictions_4 <- predict(model_train_4, newdata = test_data4, type = "response")
train_predictions_4 <- predict(model_train_4, newdata = train_data4, type = "response")
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
print(paste("Train RMSE:", round(rmse_train_4, 2)))
print(paste("Test RMSE:", round(rmse_test_4, 2)))
# ===== RMSE =====
rmse_test_4 <- sqrt(mean((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE))
rmse_train_4 <- sqrt(mean((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE))
# ===== MAE (Mean Absolute Error) =====
mae_test_4 <- mean(abs(test_data4$filings_2020 - test_predictions_4), na.rm = TRUE)
mae_train_4 <- mean(abs(train_data4$filings_2020 - train_predictions_4), na.rm = TRUE)
# ===== R² (R-squared) =====
# Test R²
ss_res_test <- sum((test_data4$filings_2020 - test_predictions_4)^2, na.rm = TRUE)
ss_tot_test <- sum((test_data4$filings_2020 - mean(test_data4$filings_2020, na.rm = TRUE))^2, na.rm = TRUE)
r2_test_4 <- 1 - (ss_res_test / ss_tot_test)
# Train R²
ss_res_train <- sum((train_data4$filings_2020 - train_predictions_4)^2, na.rm = TRUE)
ss_tot_train <- sum((train_data4$filings_2020 - mean(train_data4$filings_2020, na.rm = TRUE))^2, na.rm = TRUE)
r2_train_4 <- 1 - (ss_res_train / ss_tot_train)
# ===== Print Results =====
cat("\n=== Model 4 Performance Metrics ===\n\n")
cat("TRAINING SET:\n")
cat(sprintf("  RMSE: %.2f\n", rmse_train_4))
cat(sprintf("  MAE:  %.2f\n", mae_train_4))
cat(sprintf("  R²:   %.4f\n\n", r2_train_4))
cat("TEST SET:\n")
cat(sprintf("  RMSE: %.2f\n", rmse_test_4))
cat(sprintf("  MAE:  %.2f\n", mae_test_4))
cat(sprintf("  R²:   %.4f\n\n", r2_test_4))
# ===== Create comparison dataframe =====
metrics_df <- data.frame(
Metric = c("RMSE", "MAE", "R²"),
Train = c(rmse_train_4, mae_train_4, r2_train_4),
Test = c(rmse_test_4, mae_test_4, r2_test_4),
Difference = c(
rmse_test_4 - rmse_train_4,
mae_test_4 - mae_train_4,
r2_train_4 - r2_test_4  # Note: for R², we want train - test
)
)
print(metrics_df)
library(pscl)
install.packages('pscl')
library(pscl)
# ===== McFadden's R² =====
# Method 1: Using pscl package (easiest)
mcfadden_r2 <- pR2(model_train_4)["McFadden"]
cat(sprintf("McFadden's R²: %.4f\n", mcfadden_r2))
# Method 2: Manual calculation (more control)
# Fit null model (intercept only with offset)
null_model <- glm.nb(
filings_2020 ~ 1 + offset(log_pop),
data = train_data4
)
# Calculate McFadden's R²
logLik_full <- logLik(model_train_4)[1]
logLik_null <- logLik(null_model)[1]
mcfadden_r2_manual <- 1 - (logLik_full / logLik_null)
cat(sprintf("\nMcFadden's R² (manual): %.4f\n", mcfadden_r2_manual))
# Adjusted McFadden's R²
k <- length(coef(model_train_4))  # number of parameters
mcfadden_adj <- 1 - ((logLik_full - k) / logLik_null)
cat(sprintf("Adjusted McFadden's R²: %.4f\n", mcfadden_adj))
